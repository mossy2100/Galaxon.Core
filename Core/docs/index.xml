<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Galaxon.Core</name>
    </assembly>
    <members>
        <member name="T:Galaxon.Core.Collections.XCollection">
            <summary>
                Extension methods for ICollection and ICollection{T}.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.XCollection.IsEmpty(System.Collections.ICollection)">
            <summary>
                Check if an ICollection (array, list, etc.) is null or empty.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Collections.XDictionary">
            <summary>
                Extension methods for Dictionary.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.XDictionary.Flip``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
                Create a new dictionary from the instance with keys and values flipped.
            </summary>
            <param name="dict">The instance.</param>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <returns>The flipped dictionary.</returns>
            <exception cref="T:Galaxon.Core.Exceptions.ArgumentInvalidException">
                If the instance contains duplicate values.
            </exception>
        </member>
        <member name="T:Galaxon.Core.Collections.XEnumerable">
            <summary>
                Extension methods for IEnumerable and IEnumerable{T}.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.XEnumerable.Diff``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Return list1 with values from list2 removed. Supports duplicates, so this is not the
                same as set difference. For example, if list1 has two instances of "cat" and list2
                has one instance of "cat", the result will have one instance of "cat".
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.XEnumerable.ToDictionary``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Convert an IEnumerable{T} into a dictionary with the dictionary's keys set to the
                index. This can be useful when the index is meaningful and you want to filter on it.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Enums.XEnum.GetDescription(System.Enum)">
            <summary>
                Get the value of the Description attribute for the enum value, or, if not provided,
                the name of the value (same as ToString()).
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Galaxon.Core.Exceptions.ArgumentFormatException">
            <summary>
                This exception type is useful for an ArgumentException that is also a
                FormatException. The usual FormatException is probably best reserved for situations
                not involving method parameters, e.g. parsing a file. I'm using the same parameter
                order here as used by ArgumentNullException and ArgumentOutOfRangeException. i.e.
                (paramName, message), for consistency. The base class, ArgumentException, has the
                parameters in a different order, i.e. (message, paramName), which can be confusing.
                For this reason, I've resolved not to use ArgumentException anymore but to treat it
                as an abstract base class. This will avoid the issue with the arguments being out of
                order, and the lack of specificity. Normally for any ArgumentException we want to
                identify the argument causing the exception (which should be done using nameof()),
                unless there are several, in which case the offending arguments can be identified in
                the message.
            </summary>
            <see cref="T:System.ArgumentException"/>
            <see cref="T:System.ArgumentNullException"/>
            <see cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor">
            <summary>
                Initializes a new instance of the ArgumentFormatException class.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the ArgumentFormatException class with an error
                message, and (optionally) a reference to the inner exception that is the cause of
                this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor(System.String,System.String,System.Exception)">
            <summary>
                Initializes a new instance of the ArgumentFormatException class with the parameter
                name, an error message, and (optionally) a reference to the inner exception that is
                the cause of this exception.
            </summary>
            <param name="paramName">The parameter name.</param>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.ArgumentInvalidException">
            <summary>
                TODO Rethink the need for this. It essentially replicates the purpose of
                ArgumentOutOfRangeException. This exception type is useful for an ArgumentException
                when the argument is invalid for a reason other than being null, out of range, or
                having an invalid format. I'm using the same parameter order here as used by
                ArgumentNullException and ArgumentOutOfRangeException, i.e. (paramName, message),
                for consistency. The base class, ArgumentException, has the parameters in a
                different order, i.e. (message, paramName), which can be confusing. I've resolved
                not to use ArgumentException anymore but to treat it as an abstract base class. This
                will avoid the issue with the arguments being out of order, and the lack of
                specificity. Normally for any ArgumentException we want to identify the argument
                causing the exception (which should be done using nameof()), unless there are
                several, in which case the offending arguments can be identified in the message.
            </summary>
            <see cref="T:System.ArgumentException"/>
            <see cref="T:System.ArgumentNullException"/>
            <see cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor">
            <summary>
                Initializes a new instance of the ArgumentInvalidException class.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the ArgumentInvalidException class with an error
                message, and (optionally) a reference to the inner exception that is the cause of
                this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor(System.String,System.String,System.Exception)">
            <summary>
                Initializes a new instance of the ArgumentInvalidException class with the parameter
                name, an error message, and (optionally) a reference to the inner exception that is
                the cause of this exception.
            </summary>
            <param name="paramName">The parameter name.</param>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.DataNotFoundException">
            <summary>
                Exception for when an attempt is made to obtain data from a database, but it isn't
                found. It's a bit more specific than DataException, and sometimes
                ObjectNotFoundException is not exactly what is meant.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.DataNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the DataNotFoundException class with an error message
                (optional), and a reference to the inner exception that is the cause of this
                exception (optional).
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.NoMatchingCaseException">
            <summary>
                This exception type is similar to ArgumentOutOfRangeException, except intended for
                use in switch statements and expressions, when the value being tested matches none
                of the case patterns.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.NoMatchingCaseException.#ctor">
            <summary>
                Initializes a new instance.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.NoMatchingCaseException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance with an error message, and (optionally) a reference to
                the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Numbers.ConvertBase">
            <summary>
                This class supports conversion between integers and strings of digits in a specified
                base, which can be in the range 2..64.

                All built-in integer types are supported, including Int128, UInt128, and BigInteger.

                Most languages support conversion to and from base 2 to 36, formed from the 10
                digits plus the 26 letters in the English alphabet. To this sequence I've appended
                28 non-alphanumeric (symbol) ASCII characters in order to extend the range of
                supported bases to 64. The symbols are appended to the standard 36 digits in ASCII
                value order. These characters only require 1 byte in UTF-8 and I assume all, or
                almost all, computer keyboards will support all of them. This has been done to add
                support for base 64, mainly for my own amusement, and to provide an alternative to
                bog-standard Base64 encoding (see link).

                The most important difference is that this encoding uses 8 bits per base-64 digit,
                whereas standard base64 encoding uses 5 bits per digit, which is more compressed.
                Another difference is that the base 64 digits used here are compatible with the
                digits used by hexadecimal and all other bases.

                ASCII provides 32 symbol (or punctuation) characters. The 4 unused characters are
                '.' (period), ',' (comma), and '_' (underscore), which can be used as group
                separators (in different contexts), and '"' (double quote) which is the string
                delimiter in C#.

                As in hexadecimal literals, upper-case letters have the same value as lower-case
                letters. Use the parameter "letterCase" to specify for the result to use all lower-
                or all upper-case letters. See the method documentation for ToBase() for how to use
                this parameter. The default is to use lower-case for all letters except for L (see
                the Digits constant). Upper-case letters are more easily confused with numerals than
                lower-case. For example: - 'O' can look like '0' - 'I' can look like '1' - 'Z' can
                look like '2' - 'S' can look like '5' - 'G' can look like '6' - 'B' can look like
                '8' The only similar problem with lower-case letters is that 'l' can look like '1'.
                To solve this, upper-case is used for this letter only. (This is the same reason why
                we use "L" as a suffix for long literals in C#, as a rule.) These days, most fonts,
                especially those used by IDEs, make it easy enough to distinguish between letters
                and numbers, so it's not the issue it once was. Multiple coding standards for CSS
                require lower-case hex digits in color literals. "L" is not a hexadecimal digit, so
                this behaviour doesn't violate that standard. Other than that, I can't find any
                standards that mandate one over the other. It seems upper-case is favoured in older
                languages, lower-case in newer.

                The core methods are ToBase() and FromBase(). In addition, convenience methods are
                provided in the form of "To" and "From" methods for all bases that are a power of 2,
                and base 10 (decimal), which are the most commonly used:
                |------------------|------------------------|--------|--------------------------| |
                Bits per digit | Numeral system | Base | Methods |
                |------------------|------------------------|--------|--------------------------| |
                1 | binary | 2 | ToBin() FromBin() | | 2 | quaternary | 4 | ToQuat() FromQuat() | |
                3 | octal | 8 | ToOct() FromOct() | | | decimal | 10 | ToDec() FromDec() | | 4 |
                hexadecimal | 16 | ToHex() FromHex() | | 5 | triacontakaidecimal * | 32 | ToTria()
                FromTria() | | 6 | tetrasexagesimal ** | 64 | ToTetra() FromTetra() |
                |------------------|------------------------|--------|--------------------------|

                * The term for base 32 is "duotrigesimal". However, there are multiple methods in
                use for encoding base 32 digits; the one used here is called "triacontakaidecimal"
                (see link below), also known as "base32hex". It's the same encoding used in Java in
                JavaScript. The term is abbreviated here as "Tria" in the names of the conversion
                methods.

                ** The term for Base 64 is "tetrasexagesimal". The term is abbreviated here as
                "Tetra" in the names of the conversion methods.

            </summary>
            <see href="https://en.wikipedia.org/wiki/List_of_numeral_systems"/>
            <see href="https://en.wikipedia.org/wiki/Binary_number"/>
            <see href="https://en.wikipedia.org/wiki/Quaternary_numeral_system"/>
            <see href="https://en.wikipedia.org/wiki/Octal"/>
            <see href="https://en.wikipedia.org/wiki/Hexadecimal"/>
            <see href="https://en.wikipedia.org/wiki/Base32"/>
            <see href="https://en.wikipedia.org/wiki/Base64"/>
        </member>
        <member name="F:Galaxon.Core.Numbers.ConvertBase.MinBase">
            <summary>The minimum base supported by the type.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.ConvertBase.MaxBase">
            <summary>The maximum base supported by the type.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.ConvertBase.Digits">
            <summary>Valid digits as a string, supporting up to base 64.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.ConvertBase.ThinSpace">
            <summary>Unicode thin space character. Can be useful for formatting numbers.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToBase``1(``0,System.Byte,System.Nullable{System.Boolean})">
            <summary>
                Convert an integer to a string of digits in a given base. Note, a negative value
                will be converted to a non-negative value with the same underlying bits. This
                reflects the behaviour of other base-conversion methods in .NET.
            </summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The instance value.</param>
            <param name="toBase">The base to convert to.</param>
            <param name="letterCase">
                If letters should be lower-case, upper-case, or default. null = default (all
                lower-case except for L; see Digits) true = upper-case false = lower-case
            </param>
            <returns>The string of digits.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If the base is out of range.
            </exception>
            <exception cref="T:Galaxon.Core.Exceptions.ArgumentInvalidException">If T is an
                unsupported type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToBin``1(``0)">
            <summary>Convert an integer to binary digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <returns>The value as a string of binary digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToQuat``1(``0)">
            <summary>Convert integer to quaternary digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <returns>The value as a string of quaternary digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToOct``1(``0)">
            <summary>Convert integer to octal digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <returns>The value as a string of octal digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToDec``1(``0)">
            <summary>Convert an integer to decimal digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <returns>The value as a string of decimal digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToHex``1(``0,System.Nullable{System.Boolean})">
            <summary>Convert integer to hexadecimal digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <param name="letterCase">If letters should be lower-case, upper-case, or default.
            </param>
            <returns>The value as a string of hexadecimal digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToTria``1(``0,System.Nullable{System.Boolean})">
            <summary>Convert integer to triacontakaidecimal (base 32) digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <param name="letterCase">If letters should be lower-case, upper-case, or default.
            </param>
            <returns>The value as a string of triacontakaidecimal digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.ToTetra``1(``0,System.Nullable{System.Boolean})">
            <summary>Convert integer to tetrasexagesimal (base 64) digits.</summary>
            <typeparam name="T">The integer type.</typeparam>
            <param name="n">The integer to convert.</param>
            <param name="letterCase">If letters should be lower-case, upper-case, or default.
            </param>
            <returns>The value as a string of tetrasexagesimal digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromBase``1(System.String,System.Byte)">
            <summary>
                Convert a string of digits in a given base into a int. Group separator characters,
                including spaces, newlines, thin spaces, periods, commas, and underscores, will be
                ignored.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">A string of digits in the specified base.</param>
            <param name="fromBase">The base that the digits in the string are in.</param>
            <returns>The integer equivalent of the digits.</returns>
            <exception cref="T:System.ArgumentNullException">If string is null, empty, or
                whitespace.
            </exception>
            <exception cref="T:Galaxon.Core.Exceptions.ArgumentFormatException">
                If string contains invalid characters for the specified base.
            </exception>
            <exception cref="T:System.InvalidCastException">If a cast to the target type failed.
            </exception>
            <exception cref="T:System.OverflowException">
                If the resulting value is out of range for the target type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromBin``1(System.String)">
            <summary>
                Convert a string of binary digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromQuat``1(System.String)">
            <summary>
                Convert a string of quaternary digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromOct``1(System.String)">
            <summary>
                Convert a string of octal digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromDec``1(System.String)">
            <summary>
                Convert a string of decimal digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromHex``1(System.String)">
            <summary>
                Convert a string of hexadecimal digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromTria``1(System.String)">
            <summary>
                Convert a string of triacontakaidecimal digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.FromTetra``1(System.String)">
            <summary>
                Convert a string of tetrasexagesimal digits into an integer.
            </summary>
            <typeparam name="T">The integer type to create.</typeparam>
            <param name="digits">The string of digits to parse.</param>
            <returns>The integer equivalent of the digits.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.CheckBase(System.Byte)">
            <summary>
                Checks if the provided base is valid for use by this class.
            </summary>
            <param name="radix">The base to check.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the base is out of range.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.ConvertBase.GetDigitValues(System.Byte)">
            <summary>
                Get the values of valid digits for the specified base.
            </summary>
            <param name="radix">The base.</param>
            <returns>The map of digit characters to their values.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.XBigInteger">
            <summary>Extension methods for BigInteger.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XBigInteger.s_gcdCache">
            <summary>
                Cache for GreatestCommonDivisor().
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.ToUnsigned(System.Numerics.BigInteger)">
            <summary>
                Get the unsigned, twos-complement version of the value, containing the fewest number
                of bytes.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.Reverse(System.Numerics.BigInteger)">
            <summary>
                Reverse a BigInteger. e.g. 123 becomes 321.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.IsPalindromic(System.Numerics.BigInteger)">
            <summary>
                Check if a BigInteger is palindromic.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.DigitSum(System.Numerics.BigInteger)">
            <summary>
                Sum of the digits in a BigInteger. If present, a negative sign is ignored.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.NumDigits(System.Numerics.BigInteger)">
            <summary>
                Get the number of digits in the BigInteger. The result will be the same for a
                positive or negative value. I tried doing this with double.Log() but because double
                is imprecise it gives wrong results for values close to but less than powers of 10.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.LeastCommonMultiple(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
                Find the smallest integer which is a multiple of both arguments. Synonyms: lowest
                common multiple, smallest common multiple. For example, the LCM of 4 and 6 is 12.
                When adding fractions, the lowest common denominator is equal to the LCM of the
                denominators.
            </summary>
            <param name="a">First integer.</param>
            <param name="b">Second integer.</param>
            <returns>The least common multiple.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
                Determine the greatest common divisor of two integers. Synonyms: greatest common
                factor, highest common factor.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.Sum(System.Collections.Generic.IEnumerable{System.Numerics.BigInteger})">
            <summary>
                Get the sum of all values in the collection.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBigInteger.Sum(System.Collections.Generic.IEnumerable{System.Numerics.BigInteger},System.Func{System.Numerics.BigInteger,System.Numerics.BigInteger})">
            <summary>
                Get the sum of all values in the collection, transformed by the supplied function.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XBinaryInteger">
            <summary>
                Extension methods for IBinaryInteger{T}.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XBinaryInteger.SuperscriptChars">
            <summary>
                Map from normal integer characters to their superscript versions.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XBinaryInteger.SubscriptChars">
            <summary>
                Map from normal integer characters to their subscript versions.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBinaryInteger.ToSuperscript``1(``0)">
            <summary>
                Render an integer as a superscript string. This is useful for formatting exponents,
                numerators, and other numeric superscripts when HTML is unavailable. See
                <see href="https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts"/>
                See
                <see href="https://rupertshepherd.info/resource_pages/superscript-letters-in-unicode"/>
                See
                <see href="https://unicode-table.com/en/"/>
            </summary>
            <param name="n">The integer.</param>
            <returns>The string of superscript characters.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XBinaryInteger.ToSubscript``1(``0)">
            <summary>
                Render an integer as a subscript string. This is useful for formatting denominators,
                the number of atoms in a molecule, atomic numbers, and other numeric subscripts when
                HTML is unavailable.
            </summary>
            <param name="n">The integer.</param>
            <returns>The string of subscript characters.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.XDecimal">
            <summary>Extension methods for decimal.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDecimal.NumExpBits">
            <summary>The number of bits in the exponent.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDecimal.NumIntBits">
            <summary>The number of bits in the integer part.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDecimal.MaxScale">
            <summary>The minimum scale factor (inverse decimal exponent).</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Log(System.Decimal)">
            <summary>
                Calculate the natural logarithm of a decimal. The algorithm is from:
                <see href="https://en.wikipedia.org/wiki/Natural_logarithm"/>
                DecimalEx.Log() hangs for very small values, so I made this version, which doesn't.
                It's tested, fast, and doesn't break with the largest or smallest decimal values.
                <see cref="M:System.Math.Log(System.Double)"/>
            </summary>
            <param name="m">A decimal value.</param>
            <returns>The natural logarithm of the given value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the argument is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Log(System.Decimal,System.Decimal)">
            <summary>
                Logarithm of a decimal in a specified base.
                <see cref="M:System.Math.Log(System.Double,System.Double)"/>
                <see cref="M:Galaxon.Core.Numbers.XDecimal.Log(System.Decimal,System.Decimal)"/>
            </summary>
            <param name="m">The decimal value.</param>
            <param name="b">The base.</param>
            <returns>The logarithm of z in base b.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the number is less than or equal to 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the base is less than or equal to 0, or equal to 1.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Log10(System.Decimal)">
            <summary>
                Logarithm of a decimal in base 10.
                <see cref="M:System.Math.Log10(System.Double)"/>
                <see cref="M:Galaxon.Core.Numbers.XDecimal.Log10(System.Decimal)"/>
            </summary>
            <param name="m">The decimal value.</param>
            <returns>The logarithm of the number in base 10.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the number is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Exp10(System.Decimal)">
            <summary>
                Calculate 10 raised to a decimal power.
            </summary>
            <param name="m">A decimal value.</param>
            <returns>10^d</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Log2(System.Decimal)">
            <summary>
                Logarithm of a decimal in base 2.
            </summary>
            <param name="m">The decimal value.</param>
            <returns>The logarithm of the number in base 2.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the number is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Exp2(System.Decimal)">
            <summary>
                Calculate 2 raised to a decimal power.
            </summary>
            <param name="m">A decimal value.</param>
            <returns>2^d</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Sinh(System.Decimal)">
            <summary>
                Hyperbolic sine.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic sine of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Cosh(System.Decimal)">
            <summary>
                Hyperbolic cosine.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic cosine of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Tanh(System.Decimal)">
            <summary>
                Hyperbolic tangent.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic tangent of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Asinh(System.Decimal)">
            <summary>
                Inverse hyperbolic sine.
            </summary>
            <param name="x">The hyperbolic sine of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Acosh(System.Decimal)">
            <summary>
                Inverse hyperbolic cosine.
            </summary>
            <param name="x">The hyperbolic cosine of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Atanh(System.Decimal)">
            <summary>
                Inverse hyperbolic tangent.
            </summary>
            <param name="x">The hyperbolic tangent of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.IsInteger(System.Decimal)">
            <summary>
                Check if a decimal value is an integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.RoundSigFigs(System.Decimal,System.Int32)">
            <summary>
                Round off a value to a given number of significant figures.
            </summary>
            <param name="m">The number to round.</param>
            <param name="n">The number of significant figures.</param>
            <returns>The rounded number.</returns>
            TODO: Test. If digits is too high an exception will be thrown, so this needs to be
            checked.
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.GetRandom">
            <summary>
                Returns a random decimal.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Disassemble(System.Decimal)">
            <summary>
                Disassemble the decimal into bitwise parts.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDecimal.Assemble(System.Byte,System.Byte,System.UInt128)">
            <summary>
                Assemble a new decimal value from bitwise parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="scaleBits">The scale bits.</param>
            <param name="intBits">The integer bits.</param>
            <returns>The new decimal.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.XDouble">
            <summary>Extension methods and other bonus stuff for double.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDouble.Delta">
            <summary>
                The default maximum difference between 2 double values being compared for equality.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDouble.NumExpBits">
            <summary>The number of bits in the exponent.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDouble.NumFracBits">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDouble.MinExp">
            <summary>The minimum binary exponent supported by the type.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XDouble.MaxExp">
            <summary>The maximum binary exponent supported by the type.</summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XDouble.MaxPosSubnormalValue">
            <summary>
                The maximum positive subnormal value.
            </summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XDouble.MinPosNormalValue">
            <summary>
                The minimum positive normal value.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.RoundSigFigs(System.Double,System.Int32)">
            <summary>
                Round off a value to a given number of significant figures.
            </summary>
            <param name="d">The number to round.</param>
            <param name="nSigFigs">The number of significant figures.</param>
            <returns>The rounded number.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.Disassemble(System.Double)">
            <summary>
                Disassemble the double into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
                Assemble a new double from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new double.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.GetRandom">
            <summary>
                Get a random double.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.IsPositiveInteger(System.Double)">
            <summary>
                Check if a double is a positive integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.IsNegativeInteger(System.Double)">
            <summary>
                Check if a double is a negative integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.IsPerfectSquare(System.Double)">
            <summary>
                Check if a value is a perfect square.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.FuzzyEquals(System.Double,System.Double,System.Double)">
            <summary>
                Check if 2 double values are equal for practical purposes. If two double values
                differ only by the least significant bit, this is more likely due to inaccuracies in
                floating point representations than actual inequality. This code is copied/adapted
                from Google Guava DoubleMath.fuzzyEquals().
                <see href="https://github.com/google/guava/blob/master/guava/src/com/google/common/math/DoubleMath.java#L360"/>
                I initially tried the algorithm from the Microsoft documentation, it didn't work in
                all cases.
                <see href="https://learn.microsoft.com/en-us/dotnet/api/system.double.equals?view=net-7.0#system-double-equals(system-double)"/>
            </summary>
            <param name="a">First number.</param>
            <param name="b">Second number.</param>
            <param name="tolerance">The maximum allowable difference between them.</param>
            <returns>If close enough to equal.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.FuzzyEquals(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
                Compare two nullable doubles for fuzzy equality.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.FuzzyIsInteger(System.Double,System.Double)">
            <summary>
                IsInteger() can be a bit strict. This method allows for some fuzziness.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.FuzzyIsPositiveInteger(System.Double,System.Double)">
            <summary>
                Check if a double is a positive integer, with some fuzziness.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XDouble.FuzzyIsNegativeInteger(System.Double,System.Double)">
            <summary>
                Check if a double is a negative integer, with some fuzziness.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XFloat">
            <summary>Extension methods and other bonus stuff for float.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XFloat.NumExpBits">
            <summary>The number of bits in the exponent.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XFloat.NumFracBits">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XFloat.MinExp">
            <summary>The minimum binary exponent supported by the type.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XFloat.MaxExp">
            <summary>The maximum binary exponent supported by the type.</summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XFloat.MaxPosSubnormalValue">
            <summary>
                The maximum positive subnormal value.
            </summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XFloat.MinPosNormalValue">
            <summary>
                The minimum positive normal value.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloat.Disassemble(System.Single)">
            <summary>
                Disassemble the float into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloat.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
                Assemble a new float from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new float.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloat.GetRandom">
            <summary>
                Get a random float.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XFloatingPoint">
            <summary>Extension methods for IFloatingPoint{T}.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.GetNumExpBits``1">
            <summary>
                Get the number of exponent bits.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.GetNumFracBits``1">
            <summary>
                Get the number of fraction bits.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.GetMinExp``1">
            <summary>
                Get the minimum exponent for the type.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.GetMaxExp``1">
            <summary>
                Get the maximum exponent for the type.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.GetMinPosNormalValue``1">
            <summary>
                Get the minimum positive normal value for the type.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.Disassemble``1(``0)">
            <summary>
                Disassemble the floating point value into its bitwise components.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XFloatingPoint.Assemble``1(System.Byte,System.UInt16,System.UInt64)">
            <summary>
                Assemble a new floating point value from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <typeparam name="T">A floating point type.</typeparam>
            <returns>The new floating point value.</returns>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.
            </exception>
        </member>
        <member name="T:Galaxon.Core.Numbers.XHalf">
            <summary>Extension methods and other bonus stuff for Half.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XHalf.NumExpBits">
            <summary>The number of bits in the exponent.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XHalf.NumFracBits">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XHalf.MinExp">
            <summary>The minimum binary exponent supported by the type.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.XHalf.MaxExp">
            <summary>The maximum binary exponent supported by the type.</summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XHalf.MaxPosSubnormalValue">
            <summary>
                The maximum positive subnormal value.
            </summary>
        </member>
        <member name="P:Galaxon.Core.Numbers.XHalf.MinPosNormalValue">
            <summary>
                The minimum positive normal value.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XHalf.Disassemble(System.Half)">
            <summary>
                Disassemble the Half into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XHalf.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
                Assemble a new Half from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new Half.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XHalf.GetRandom">
            <summary>
                Get a random Half.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XInt">
            <summary>Extension methods for int.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XInt.Sqrt(System.Int32)">
            <summary>
                Get the int closest to the square root of the given int.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XInt.Abs(System.Int32)">
            <summary>
                Return the absolute value of an int as a uint. This addresses an issue with
                int.Abs(), which is that Abs(int.MinValue) can't be expressed as a int, and so
                wrap-around occurs. Unsigned integer types don't have an Abs() method, so there's no
                collision.
            </summary>
            <param name="n">A int value.</param>
            <returns>The absolute value as a uint.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XInt.GetRandom">
            <summary>
                Get a random int.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XLong">
            <summary>Extension methods for long.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XLong.Pow(System.Int64,System.Int64)">
            <summary>
                Get the long value closest to x^y.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XLong.Sqrt(System.Int64)">
            <summary>
                Get the long value closest to √x.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XLong.Abs(System.Int64)">
            <summary>
                Return the absolute value of a long as a ulong. This addresses an issue with
                long.Abs(), which is that Abs(long.MinValue) can't be expressed as a long, and so
                wrap-around occurs. Unsigned integer types don't have an Abs() method, so there's no
                collision.
            </summary>
            <param name="n">A long value.</param>
            <returns>The absolute value as a ulong.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XLong.GetRandom">
            <summary>
                Get a random long.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XNumber">
            <summary>Extension methods for numbers (INumber{T} and INumberBase{T}).</summary>
            <remarks>
                TODO: Sort out methods to check for implementation of generic interfaces.
            </remarks>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.Implements(System.Object,System.Type)">
            <summary>
                Check if a type implements a generic interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsSignedInteger(System.Object)">
            <summary>
                Check if an object is a signed integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsUnsignedInteger(System.Object)">
            <summary>
                Check if an object is an unsigned integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsFloatingPoint(System.Object)">
            <summary>
                Check if an object is a floating point value.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsInteger(System.Object)">
            <summary>
                Check if an object is an integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsReal(System.Object)">
            <summary>
                Check if an object is a real (non-complex) number.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsComplex(System.Object)">
            <summary>
                Check if an object is a complex number.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.IsNumber(System.Object)">
            <summary>
                Check if an object is a number.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.DivMod``1(``0,``0)">
            <summary>
                Integer division and modulo operation using floored division. The modulus will
                always have the same sign as the divisor. Unlike the truncated division and modulo
                provided by C#'s operators, floored division produces a regular cycling pattern
                through both negative and positive values of the divisor. It permits things like:
                bool isOdd = Mod(num, 2) == 1; Trying to do this using the % operator will fail for
                negative divisors, however. e.g. bool isOdd = num % 2 == 1; In this case, if num is
                negative 0, num % 2 == -1
            </summary>
            <see href="https://en.wikipedia.org/wiki/Modulo_operation"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.Div``1(``0,``0)">
            <summary>
                Corrected integer division operation.
            </summary>
            <see cref="M:Galaxon.Core.Numbers.XNumber.DivMod``1(``0,``0)"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.Mod``1(``0,``0)">
            <summary>
                Corrected modulo operation.
            </summary>
            <see cref="M:Galaxon.Core.Numbers.XNumber.DivMod``1(``0,``0)"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.Product``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Similar to Sum(), this extension method generates the product of all values in a
                collection of numbers.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XNumber.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
                Similar to Sum(), get a product of all values in the collection, transformed by the
                supplied function.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XSbyte">
            <summary>Extension methods for sbyte.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XSbyte.Abs(System.SByte)">
            <summary>
                Return the absolute value of an sbyte as a byte. This addresses an issue with
                sbyte.Abs(), which is that Abs(sbyte.MinValue) can't be expressed as a sbyte, and so
                wrap-around occurs. Unsigned integer types don't have an Abs() method, so there's no
                collision.
            </summary>
            <param name="n">A sbyte value.</param>
            <returns>The absolute value as a byte.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.XShort">
            <summary>Extension methods for short.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XShort.Abs(System.Int16)">
            <summary>
                Return the absolute value of a short as a ushort. This addresses an issue with
                short.Abs(), which is that Abs(short.MinValue) can't be expressed as a short, and so
                wrap-around occurs. Unsigned integer types don't have an Abs() method, so there's no
                collision.
            </summary>
            <param name="n">A short value.</param>
            <returns>The absolute value as a ushort.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.XShort.GetRandom">
            <summary>
                Get a random short.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XUint">
            <summary>Extension methods for uint.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XUint.GetRandom">
            <summary>
                Get a random uint.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XUlong">
            <summary>Extension methods for ulong.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XUlong.GetRandom">
            <summary>
                Get a random ulong.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XUlong.Sum(System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
                Get the sum of all values in the collection.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XUlong.Sum(System.Collections.Generic.IEnumerable{System.UInt64},System.Func{System.UInt64,System.UInt64})">
            <summary>
                Get the sum of all values in the collection, transformed by the supplied function.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.XUshort">
            <summary>Extension methods for ushort.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.XUshort.GetRandom">
            <summary>
                Get a random ushort.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Strings.XString">
            <summary>
                Extension methods for String.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.XString.SmallCapsChars">
            <summary>
                Map from lower-case letters to their Unicode small caps equivalents.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.EqualsIgnoreCase(System.String,System.String)">
            <summary>
                See if 2 strings are equal, ignoring case.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ReplaceChars(System.String,System.Collections.Generic.Dictionary{System.Char,System.String},System.Boolean)">
            <summary>
                Replace characters in a string with other characters by using a character map.
                Example use cases: * making a string upper- or lower-case * converting lowercase
                characters to small caps * making a string superscript or subscript *
                transliteration/removal of diacritics
            </summary>
            <param name="str">The original string.</param>
            <param name="charMap">The character map.</param>
            <param name="keepCharsNotInMap">
                If a character is encountered that is not in the character map, either keep it
                (true) or skip it (false).
            </param>
            <returns>The transformed string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.Repeat(System.String,System.Int32)">
            <summary>
                Construct a new string by repeating a string multiple times.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.Reverse(System.String)">
            <summary>
                Reverse a string. e.g. "You are awesome." becomes ".emosewa era uoY".
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.IsPalindrome(System.String)">
            <summary>
                Check if a string is a palindrome.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.StripWhitespace(System.String)">
            <summary>
                Remove whitespace from a string.
            </summary>
            <see href="https://www.compart.com/en/unicode/category/Zs"/>
            <param name="str">The string to process.</param>
            <returns>The string with whitespace characters removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.StripBrackets(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Remove brackets (and whatever's between them) from a string.
            </summary>
            <param name="str">The string to process.</param>
            <param name="round">If round brackets should be removed.</param>
            <param name="square">If square brackets should be removed</param>
            <param name="curly">If curly brackets should be removed</param>
            <param name="angle">If angle brackets should be removed</param>
            <returns>The string with brackets removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.StripTags(System.String)">
            <summary>Strip HTML tags from a string.</summary>
            <param name="str">The string to process.</param>
            <returns>The string with HTML tags removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.IsAscii(System.String)">
            <summary>
                Check if a string contains only ASCII characters.
            </summary>
            <param name="str">The string to check.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToSmallCaps(System.String)">
            <summary>
                Convert all lower-case letters in a string to their Unicode small caps variant. Only
                works for English letters, so, if necessary (e.g. if the string is in a different
                language), you may wish to call AnyAscii.Transliterate() on the string first.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToSuperscript(System.String)">
            <summary>
                Render a string with valid integer characters (i.e. minus sign or digits) converted
                to their Unicode superscript versions.
            </summary>
            <param name="str">The string.</param>
            <returns>The string of superscript characters.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToSubscript(System.String)">
            <summary>
                Render a string with valid integer characters (i.e. minus sign or digits) converted
                to their Unicode subscript versions.
            </summary>
            <param name="str">The string.</param>
            <returns>The string of subscript characters.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ZeroPad(System.String,System.Int32)">
            <summary>
                Pad a string on the left with 0s to make it up to a certain width.
            </summary>
            <param name="str">The string.</param>
            <param name="width">The minimum number of characters in the the result.</param>
            <returns>The zero-padded string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.GroupDigits(System.String,System.Char,System.Byte)">
            <summary>
                Given a string of digits, format in groups using the specified group separator and
                group size. This method is designed for formatting numbers but it could be used for
                other purposes, since the method doesn't check if the characters are actually
                digits. It just assumes they are. Apart from saving time, it allows the method to be
                used for hexadecimal or other bases. Grouping starts from the right. Here's how you
                would format an integer: "12345678".GroupDigits(',', 3) => "12,345,678" You can
                chain methods if you need to, e.g. "11111000000001010101".GroupDigits('_', 8) =>
                "1111_10000000_01010101" "11111000000001010101".ZeroPad(24).GroupDigits('_', 8) =>
                "00001111_10000000_01010101" 123456789.ToHex().ZeroPad(8).GroupDigits(' ') => "075b
                cd15"
            </summary>
            <param name="str">The string, nominally of digits, but can be whatever.</param>
            <param name="separator">The group separator character.</param>
            <param name="size">The group size.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToInt(System.String)">
            <summary>
                Convert nullable string to nullable int without throwing. If the string cannot be
                parsed into an int, return null. Of course, TryParse() can be used, but this method
                is a bit more concise, and saves time thinking about nulls.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToDouble(System.String)">
            <summary>
                Convert nullable string to nullable double without throwing. If the string cannot be
                parsed into a double, return null.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XString.ToDecimal(System.String)">
            <summary>
                Convert nullable string to nullable decimal without throwing. If the string cannot
                be parsed into a decimal, return null.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Strings.XStringBuilder">
            <summary>
                Extension methods for StringBuilder.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.XStringBuilder.Prepend(System.Text.StringBuilder,System.Object)">
            <summary>
                Prepends a StringBuilder with a string. Reflects Append().
            </summary>
        </member>
        <member name="T:Galaxon.Core.Testing.XAssert">
            <summary>
                Container for my own custom Assert methods.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Testing.XAssert.AreEqual(System.ValueTuple{System.Double,System.Double,System.Double},System.ValueTuple{System.Double,System.Double,System.Double},System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>
                Helper function to compare DMS (degrees, minutes, seconds) tuples for equality.
            </summary>
            <param name="a">Angle 1</param>
            <param name="b">Angle 2</param>
            <param name="delta">Maximum acceptable difference between the two angles.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.XAssert.AreEqual(System.DateTime,System.DateTime,System.Nullable{System.TimeSpan})">
            <summary>
                Helper function to compare DateTimes for equality.
            </summary>
            <param name="dt1">The first DateTime</param>
            <param name="dt2">The second DateTime</param>
            <param name="delta">Maximum acceptable difference.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.XAssert.IsInRange(System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
                Check if a value is in a given range.
            </summary>
            <param name="value">The value to test.</param>
            <param name="lower">The lower value.</param>
            <param name="upper">The upper value.</param>
            <param name="includeLower">Include lower value in the range.</param>
            <param name="includeUpper">Include upper value in the range.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.XAssert.AreEqual(System.Double,System.Decimal)">
            <summary>
                Helper function to test if a double equals a decimal.
            </summary>
            <param name="expected">Expected double value</param>
            <param name="actual">Actual decimal value</param>
        </member>
        <member name="M:Galaxon.Core.Testing.XAssert.AreEqualPercent(System.Double,System.Double,System.Double)">
            <summary>
                Compare two double values for equality, with the delta expressed as percentage of
                the expected value rather than an absolute value.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Time.ETimeUnit">
            <summary>
                The time units supported by the conversion functions. **Note: This will be
                deprecated once Galaxon.Quantities is complete.**
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Nanosecond">
            <summary>
                Nanosecond (ns). 1 ns = 10<sup>-9</sup> s = 0.01 ticks
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Shake">
            <summary>
                Shake. 1 shake = 10<sup>-8</sup> s = 10 ns = 0.1 ticks
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Tick">
            <summary>
                The core time unit used by .NET. 1 tick = 100 ns = 0.1 µs = 10<sup>-7</sup> s
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Microsecond">
            <summary>
                Microsecond (µs). 1 µs = 10<sup>-6</sup> s = 1000 ns = 10 ticks
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Millisecond">
            <summary>
                Millisecond (ms). 1 ms = 10<sup>-3</sup> s = 1000 µs
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Second">
            <summary>
                Second (s). 1 second = 10,000,000 ticks
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Minute">
            <summary>
                Minute (min). 1 min = 60 s
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Hour">
            <summary>
                Hour (h). 1 h = 60 min = 3600 sec
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Day">
            <summary>
                Day (d). 1 d = 24 h = 86,400 min. Depending on context, this may refers to an
                ephemeris day (exactly 86,400 SI seconds), or a solar day, which is slightly longer.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Week">
            <summary>
                Week (w). 1 w = 7 d = 168 h
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Month">
            <summary>
                Month (mon). Ranges in length from 28-31 days. The average Gregorian calendar month
                length is 30.436875 d = 4.348125 w = 31,556,952 s
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Year">
            <summary>
                Year (y). This refers to a Gregorian calendar year, which is 365 or 366 days. The
                average is 365.2425 days. 1 y = 12 mon
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Decade">
            <summary>
                Decade (dec). 1 dec = 10 y
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Century">
            <summary>
                Century (c). 1 c = 10 dec = 100 y
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.ETimeUnit.Millennium">
            <summary>
                Millennium (ky). 1 ky = 10 c = 100 dec = 1000 y
            </summary>
        </member>
        <member name="T:Galaxon.Core.Time.XDateOnly">
            <summary>
                Extension methods for the DateOnly class.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XDateOnly.SortableDatePattern">
            <summary>
                Same as DateTimeFormatInfo.SortableDateTimePattern, but without the time.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.ToIsoString(System.DateOnly)">
            <summary>
                Format the date using ISO 8601 format YYYY-MM-DD.
                <see href="https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates"/>
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>A string representing the date in ISO format.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.ToDateTime(System.DateOnly)">
            <summary>
                Convert a DateOnly to a DateTime, with default time 00:00:00.
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>The new DateTime object</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.ToDateTime(System.DateOnly,System.DateTimeKind)">
            <summary>
                Convert a DateOnly to a DateTime, with default time 00:00:00 and specified
                DateTimeKind.
            </summary>
            <param name="date">The DateOnly instance.</param>
            <param name="kind">The DateTimeKind.</param>
            <returns>The new DateTime object</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetTicks(System.DateOnly)">
            <summary>
                Get the number of ticks between the start of the epoch (0001-01-01 00:00:00) and the
                start of the date. If extension properties are added to the language I may change
                this to a property "Ticks" later, for consistency with DateTime.
            </summary>
            <see href="https://learn.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=net-7.0"/>
            <param name="date">The DateOnly instance.</param>
            <returns>The number of ticks.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetTotalSeconds(System.DateOnly)">
            <summary>
                Get the number of seconds between the start of the epoch and the start of the date.
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>The number of seconds since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetTotalDays(System.DateOnly)">
            <summary>
                Get the number of days between the start of the epoch and the given date.
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>The number of days since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetTotalYears(System.DateOnly)">
            <summary>
                Get the number of years between the start of the epoch and the start of the date.
                The result will be greater than or equal to `date.Year - 1` and less than
                `date.Year`.
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>The number of years since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.Add(System.DateOnly,System.TimeSpan)">
            <summary>
                Add a period of time to a date to find a new DateTime.
            </summary>
            <see cref="M:System.DateTime.Add(System.TimeSpan)"/>
            <param name="date">The date.</param>
            <param name="period">The time period to add.</param>
            <returns>The resulting DateTime.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.Add(System.DateOnly,System.TimeOnly)">
            <summary>
                Add a time of day to a date to find a new DateTime.
            </summary>
            <param name="date">The date.</param>
            <param name="time">The time of day to add.</param>
            <returns>The resulting DateTime.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.AddWeeks(System.DateOnly,System.Int32)">
            <summary>
                Add a number of weeks to a date.
            </summary>
            <param name="date">The date.</param>
            <param name="weeks">The number of weeks to add.</param>
            <returns>The resulting date.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.Subtract(System.DateOnly,System.DateOnly)">
            <summary>
                Returns the difference between two dates as a number of days. Emulates the
                <see cref="M:System.DateTime.Subtract(System.DateTime)"/>
                method. If the end date is later than the start date, the result will be positive.
                If they are equal, the result will be zero. Otherwise, the result will be negative.
            </summary>
            <param name="end">The end date.</param>
            <param name="start">The start date.</param>
            <returns>The number of days difference between the two dates.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.FromTotalDays(System.Int64)">
            <summary>
                Find a date given the number of days from the start of the epoch.
            </summary>
            <see cref="M:Galaxon.Core.Time.XDateTime.FromTotalDays(System.Double)"/>
            <param name="days">The number of days.</param>
            <returns>The resulting date.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.FromTotalYears(System.Double)">
            <summary>
                Find the date given the number of years since the start of the epoch.
            </summary>
            <param name="years">The number of years. May include a fractional part.</param>
            <returns>The resulting date.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.FromDayOfYear(System.Int32,System.Int32)">
            <summary>
                Find a date given a year and the day of the year. Formula from Meeus (Astronomical
                Algorithms 2 ed. p66).
            </summary>
            <param name="year">The year (1..9999).</param>
            <param name="dayOfYear">The day of the year (1..366).</param>
            <returns>The resulting date.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.ToJulianDay(System.DateOnly)">
            <summary>
                Convert a DateOnly object to a Julian Day value. The result gives the Julian Day at
                the start of the given date (00:00:00, i.e. midnight), which will always have a
                fraction of 0.5, since a Julian Day starts at 12:00:00 (noon).
                <see cref="M:Galaxon.Core.Time.XDateTime.ToJulianDay(System.DateTime)"/>
            </summary>
            <param name="date">The DateOnly instance.</param>
            <returns>The Julian Day value.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.FromJulianDay(System.Double)">
            <summary>
                Convert a Julian Day value to a date.
            </summary>
            <see cref="M:Galaxon.Core.Time.XDateTime.FromJulianDay(System.Double)"/>
            <param name="jd">
                The Julian Day value. If a fractional part indicating the time of day is included,
                this information will be discarded.
            </param>
            <returns>A new DateOnly object.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetEaster(System.Int32)">
            <summary>
                Get the date of Easter Sunday in the given year. Formula is from Wikipedia. This
                method uses the "Meeus/Jones/Butcher" algorithm from 1876, with the New Scientist
                modifications from 1961. Tested for years 1600..2299.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Date_of_Easter#Anonymous_Gregorian_algorithm"/>
            <see href="https://www.census.gov/data/software/x13as/genhol/easter-dates.html"/>
            <see href="https://www.assa.org.au/edm"/>
            <param name="year">The Gregorian year number.</param>
            <returns>The date of Easter Sunday for the given year.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetChristmas(System.Int32)">
            <summary>
                Get the date of Christmas Day in the given year.
            </summary>
            <param name="year">The year.</param>
            <returns>The date of Christmas in the given year.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetNthWeekdayInMonth(System.Int32,System.Int32,System.Int32,System.DayOfWeek)">
            <summary>
                Find the nth weekday in a given month. Example:
                <code>
                    // Get the 4th Thursday in January, 2023. DateOnly meetup =
                    XDateOnly.GetNthWeekdayInMonth(2023, 1, 4, DayOfWeek.Thursday);
                </code>
                A negative value for n means count from the end of the month. n = -1 means the last
                one in the month. n = -2 means the second-last, etc. Example:
                <code>
                    // Get the last Monday in November, 2025. DateOnly meetup =
                    XDateOnly.GetNthWeekdayInMonth(2025, 11, -1, DayOfWeek.Monday);
                </code>
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="n">Which occurence of the day of the week within the month.</param>
            <param name="dayOfWeek">The day of the week.</param>
            <returns>The requested date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If Abs(n) not in the range 1..5
            </exception>
            <exception cref="T:System.InvalidOperationException">If a valid date could not be
                found.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Time.XDateOnly.GetThanksgiving(System.Int32,System.String)">
            <summary>
                Find the date of Thanksgiving for a specified country in a given year. Only years
                with a holiday called "Thanksgiving" are supported. The default is "US".
            </summary>
            <see href="https://en.wikipedia.org/wiki/Thanksgiving#Observance"/>
            <param name="year">The year.</param>
            <param name="countryCode">The ISO 2-letter country code.</param>
            <returns>The date of Thanksgiving.</returns>
            <exception cref="T:Galaxon.Core.Exceptions.ArgumentInvalidException">
                Either this country doesn't celebrate Thanksgiving, or the method doesn't support
                it.
            </exception>
        </member>
        <member name="T:Galaxon.Core.Time.XDateTime">
            <summary>
                Extension methods for the DateTime class.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XDateTime.JulianPeriodOffset">
            <summary>
                The number of days from the start of the Julian period to the start of the epoch
                used by .NET (0001-01-01 00:00:00 UTC).
                <see cref="M:Galaxon.Core.Time.XDateTime.GetTotalDays(System.DateTime)"/>
            </summary>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.ToIsoString(System.DateTime)">
            <summary>
                Format the date using ISO format YYYY-MM-DDThh:mm:ss. This format is useful for
                databases. The time zone is not shown. For that, call ToString() with the format
                specifier "U" or UniversalSortableDateTimePattern. See
                <see href="https://learn.microsoft.com/en-us/dotnet/api/system.datetime.tostring?view=net-7.0"/>
            </summary>
            <param name="date">The DateTime instance.</param>
            <returns>A string representing the datetime in ISO format.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.AddWeeks(System.DateTime,System.Double)">
            <summary>
                Add a number of weeks to a DateTime to get a new DateTime.
            </summary>
            <param name="dt">A DateTime.</param>
            <param name="weeks">The number of weeks to add.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.GetDateOnly(System.DateTime)">
            <summary>
                Get the date part of a DateTime as a DateOnly object. An alternative to the Date
                property, which returns a DateTime.
            </summary>
            <see cref="P:System.DateTime.Date"/>
            <param name="dt">The DateTime.</param>
            <returns>The date part of the DateTime.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.GetTimeOnly(System.DateTime)">
            <summary>
                Get the time part of a DateTime as a TimeOnly object. An alternative to the
                TimeOfDay property, which returns a TimeSpan.
            </summary>
            <see cref="P:System.DateTime.TimeOfDay"/>
            <param name="dt">The DateTime.</param>
            <returns>The time part of the DateTime.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.GetTotalSeconds(System.DateTime)">
            <summary>
                Get the total number of seconds from the start of the epoch to the datetime.
            </summary>
            <param name="dt">The DateTime instance.</param>
            <returns>The number of seconds since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.GetTotalDays(System.DateTime)">
            <summary>
                Get the total number of days from the start of the epoch to the datetime.
            </summary>
            <param name="dt">The DateTime instance.</param>
            <returns>The number of days since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.GetTotalYears(System.DateTime)">
            <summary>
                Get the number of years between the start of the epoch and the start of the date.
            </summary>
            <param name="dt">The DateTime instance.</param>
            <returns>The number of years since the epoch start.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.FromTotalSeconds(System.Double)">
            <summary>
                Create a new DateTime given the number of seconds since the start of the epoch.
            </summary>
            <param name="seconds">The number of seconds.</param>
            <returns>A new DateTime object.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.FromTotalDays(System.Double)">
            <summary>
                Create a new DateTime given the number of days since the start of the epoch.
            </summary>
            <param name="days">
                The number of days. May include a fractional part indicating the time of day.
            </param>
            <returns>A new DateTime object.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.FromTotalYears(System.Double)">
            <summary>
                Create a new DateTime given the number of years since the start of the epoch.
            </summary>
            <param name="years">The number of years. May include a fractional part.</param>
            <returns>A new DateTime object.</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.ToJulianDay(System.DateTime)">
            <summary>
                Express the DateTime as a Julian Day. The time of day information in the DateTime
                will be expressed as the fractional part of the return value. Note, however, a
                Julian Day begins at 12:00 noon.
            </summary>
            <param name="dt">The DateTime instance.</param>
            <returns>The Julian Day value</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XDateTime.FromJulianDay(System.Double)">
            <summary>
                Convert a Julian Day value to a DateTime object.
            </summary>
            <param name="jd">
                The Julian Day value. May include a fractional part indicating the time of day.
            </param>
            <returns>A new DateTime object.</returns>
        </member>
        <member name="T:Galaxon.Core.Time.XTimeOnly">
            <summary>
                Extension methods for TimeOnly.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Time.XTimeOnly.ToTimeSpan(System.TimeOnly)">
            <summary>
                Convert a TimeOnly to a TimeSpan.
            </summary>
            <param name="time">The TimeOnly instance.</param>
            <returns>The new TimeSpan object</returns>
        </member>
        <member name="M:Galaxon.Core.Time.XTimeOnly.Subtract(System.TimeOnly,System.TimeOnly)">
            <summary>
                Subtract a start time from an end time to find the difference.
            </summary>
            <param name="end">The end time.</param>
            <param name="start">The start time.</param>
            <returns>The time elapsed.</returns>
        </member>
        <member name="T:Galaxon.Core.Time.XTimeSpan">
            <summary>
                Additional members to supplement the TimeSpan class. Mostly constants. For
                consistency with TimeSpan, I've used `long` as the type for any integer constants.
                For non-integer constants I've used `double`. The following constants are already
                provided by the TimeSpan class and not reproduced here: - TicksPerMicrosecond -
                TicksPerMillisecond - TicksPerSecond - TicksPerMinute - TicksPerHour - TicksPerDay
                **NOTE: Any constants or methods for converting between time units will become
                obsolete with the completion of Galaxon.Quantities.** The word Month, Year, Decade,
                Century, or Millennium in a constant name usually refers to the average length of
                that time unit in the Gregorian Calendar.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Time.XTimeSpan.Convert(System.Double,Galaxon.Core.Time.ETimeUnit,Galaxon.Core.Time.ETimeUnit)">
            <summary>
                Convert a time value from one unit to another. TODO Replace with Quantity methods.
            </summary>
            <param name="amount">The amount.</param>
            <param name="fromUnit">The amount argument units.</param>
            <param name="toUnit">The result units.</param>
            <returns>The amount of the new unit.</returns>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.MinutesPerHour">
            <summary>
                The number of minutes in an hour.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.MinutesPerDay">
            <summary>
                The number of minutes in a day.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.HoursPerDay">
            <summary>
                The number of hours in an ephemeris day.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.HoursPerWeek">
            <summary>
                The number of hours in a week.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.WeeksPerMonth">
            <summary>
                The number of weeks in an average Gregorian month.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.WeeksPerYear">
            <summary>
                The number of weeks in a Gregorian year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.MonthsPerYear">
            <summary>
                The number of months in a Gregorian year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerNanosecond">
            <summary>
                The number of ticks in a nanosecond.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerWeek">
            <summary>
                The number of ticks in a week.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerMonth">
            <summary>
                The number of ticks in a month.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerYear">
            <summary>
                The number of ticks in a Gregorian year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerDecade">
            <summary>
                The number of ticks in a Gregorian decade.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerCentury">
            <summary>
                The number of ticks in a Gregorian century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerMillennium">
            <summary>
                The number of ticks in a Gregorian millennium.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerTick">
            <summary>
                The number of seconds in a nanosecond.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerMicrosecond">
            <summary>
                The number of seconds in a microsecond.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerMillisecond">
            <summary>
                The number of seconds in a millisecond.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerMinute">
            <summary>
                The number of seconds in a minute.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerHour">
            <summary>
                The number of seconds in an hour.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerDay">
            <summary>
                The number of seconds in an ephemeris day.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerWeek">
            <summary>
                The number of seconds in a week.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerMonth">
            <summary>
                The average number of seconds in a month.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerYear">
            <summary>
                The average number of seconds in a Gregorian year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerDecade">
            <summary>
                The average number of seconds in a Gregorian decade.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerCentury">
            <summary>
                The average number of seconds in a Gregorian century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerMillennium">
            <summary>
                The average number of seconds in a Gregorian millennium.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerWeek">
            <summary>
                The number of days in a week.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerMonth">
            <summary>
                The average number of days in a Gregorian month.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerYear">
            <summary>
                The average number of days in a Gregorian year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerDecade">
            <summary>
                The average number of days in a Gregorian decade.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerCentury">
            <summary>
                The average number of days in a Gregorian century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerMillennium">
            <summary>
                The average number of days in a Gregorian millennium.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.YearsPerOlympiad">
            <summary>
                Number of years in an olympiad.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.YearsPerDecade">
            <summary>
                The number of years in a decade. The precise length of a decade depends on what year
                is being used. For a example, a Gregorian decade (3652.425 d on average) will have a
                different length to an Islamic Calendar decade (about 3543.67 d on average) or a
                tropical decade (3652.42198781 d on average).
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.YearsPerCentury">
            <summary>
                The number of years in a century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.YearsPerMillennium">
            <summary>
                The number of years in a millennium.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.YearsPerSolarCycle">
            <summary>
                The Gregorian Calendars repeats on a 400-year cycle called the *solar cycle*. There
                are 97 leap years in that period, giving an average calendar year length of 365 +
                (97/400) = 365.2425 days/year. 1 Gregorian solar cycle = 400 y = 4800 mon = 20,871 w
                = 146,097 d 5 Gregorian solar cycles = 2000 y = 2 ky Solar cycles are not ordinarily
                numbered, nor given a specific start date. However, within the proleptic Gregorian
                epoch (the one used by .NET), which began on Monday, 1 Jan, 1 AD, we are currently
                in the 6th solar cycle. It began on Monday, 1 Jan, 2001, which was also the first
                day of the 3rd millennium AD. It will end on Sunday, 31 Dec, 2400. See: -
                <see href="https://en.wikipedia.org/wiki/Solar_cycle_(calendar)"/>
                -
                <see href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar"/>
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.OlympiadsPerSolarCycle">
            <summary>
                Number of olympiads in an Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.LeapYearsPerSolarCycle">
            <summary>
                The number of leap years in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.CommonYearsPerSolarCycle">
            <summary>
                The number of common years in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.MonthsPerSolarCycle">
            <summary>
                The number of months in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.WeeksPerSolarCycle">
            <summary>
                The number of weeks in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerSolarCycle">
            <summary>
                The number of days in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerSolarCycle">
            <summary>
                The number of seconds in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.TicksPerSolarCycle">
            <summary>
                The number of ticks in a Gregorian solar cycle.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerJulianYear">
            <summary>
                The number of days in a Julian Calendar year.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerJulianDecade">
            <summary>
                The number of days in a Julian Calendar decade.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerJulianCentury">
            <summary>
                The number of days in a Julian Calendar century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerJulianMillennium">
            <summary>
                The number of days in a Julian Calendar millennium.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.SecondsPerSolarDay">
            <summary>
                The number of seconds in a solar day (as at 2023). It is increasing by about 2
                milliseconds per century.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerLunation">
            <summary>
                Number of days in a synodic lunar month (a.k.a. "lunation").
            </summary>
        </member>
        <member name="F:Galaxon.Core.Time.XTimeSpan.DaysPerTropicalYear">
            <summary>
                The number of days in the mean tropical year B1900 (days). This value is taken from
                the SOFA (Standards of Fundamental Astronomy) library, which is assumed to be
                authoritative.
            </summary>
        </member>
    </members>
</doc>
